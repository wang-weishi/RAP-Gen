[PATCH] len = Math.min(len, ch);
[PATCH] len = read + 1; ch = i.read();
[PATCH] len = len +(( char)ch).length();
[PATCH] len = len + parsePaxChar(i, ch);
[PATCH] len = i.read(2);
[PATCH] len = len +(int)i.read();
[PATCH] len = len - read; ch = i.read();
[PATCH] len =(( char)ch).length();
[PATCH] len = Math.min(len, 1);
[PATCH] len =(( byte)i.read()).length();
[PATCH] len = Math.min(read, len);
[PATCH] len = len + extractPaxChar(i, ch);
[PATCH] len = ZipLong.parseLong(ch);
[PATCH] len = parsePaxChar(i, ch);
[PATCH] len = this.zipEncoding.decode(ch);
[PATCH] len = Math.min(len, CH);
[PATCH] len = len + 1 -(int)(ch >> 6);
[PATCH] len = Math.max(len, ch);
[PATCH] len = i.read(headerBuf, 0, len);
[PATCH] len = len + 1 -(int)i.read();
[PATCH] len = len +(( ch & 0x03)+ 1;
[PATCH] len = Math.min(len, read + 1);
[PATCH] len = Math.min(read + 1, len);
[PATCH] len = Math.min(len, ch + 1);
[PATCH] len = Math.max(len, read + 1);
[PATCH] len = read + 1;
[PATCH] len = i.read(1);
[PATCH] len = len + headerBuf.length;
[PATCH] len = Math.min(_read, len);
[PATCH] len = Math.min(len, 10);
[PATCH] len = Math.min(len + 1, ch);
[PATCH] len = len - read;
[PATCH] len = len + 1; ch = i.read();
[PATCH] len = Math.min(len, 8);
[PATCH] len =(( byte)ch).length();
[PATCH] len = super.parsePaxChar(i, ch);
[PATCH] len = Math.min(len, len);
[PATCH] len = i.read(buf, 0, len);
[PATCH] len =(( int)i.read()).length();
[PATCH] len = len +(( ch & 0x03)+ 1);
[PATCH] len = len + parseNextCharacter(i, ch);
[PATCH] len = Math.min(len, ch).length();
[PATCH] len = len +(int)(ch & 0x03);
[PATCH] len = i.read(new char[len - read]);
[PATCH] len =(( byte)'0' + read)).length();
[PATCH] len =(( ch & 0x03)+ 1;
[PATCH] len = len +(int)(ch >> 6);
[PATCH] len = Math.min(len, 0x80);
[PATCH] len = Math.min(len, ch - 1);
[PATCH] ch = i.read(); len = read + 1;
[PATCH] len = ZipEncodingHelper.byteArray(ch);
[PATCH] len = len + parsePaxChar(i);
[PATCH] len = len + ch.toString().length();
[PATCH] len =(( ch >> 6)& 0x03);
[PATCH] len = len + extractPaxChar(ch);
[PATCH] len = i.read(new char[len + read]);
[PATCH] len = ILLEGAL_NAME.length(ch);
[PATCH] len = Math.min(len, len + 1);
[PATCH] len = Math.min(read, 1);
[PATCH] len = Math.max(len, 1);
[PATCH] len = i.read(WS_BUFFER);
[PATCH] len = parseNextCharacter(i, ch);
[PATCH] len =(( byte)read).length();
[PATCH] len = Math.min(read, len - 1);
[PATCH] len =(( byte)i.read()).length;
[PATCH] len = headerBuf.length - read;
[PATCH] len = parsePaxHeader(i, headers);
[PATCH] len = IteratorUtils.skipWS(ch);
[PATCH] len = Math.min(len, 0x7F);
[PATCH] len =(( byte)i.read())- 1;
[PATCH] len = ILLEGAL_NAME.length();
[PATCH] len = Integer.parseInt(ch);
[PATCH] len = len + 1 -(ch >> 6);
[PATCH] len = Math.min(len, len - read);
[PATCH] len = readUnsignedShort(ch);
[PATCH] len = ReadUtils.skipWS(ch);
[PATCH] len = i.read(new char[len]);
[PATCH] len = Math.min(( int)len, ch);
[PATCH] len = String.valueOf(ch);
[PATCH] len =(len + 1)== i.read();
[PATCH] len = len + extractPaxChar(ch, i);
[PATCH] len = i.read(( char)ch);
[PATCH] len = Math.min(len, 0x10);
[PATCH] len = len - read + 1;
[PATCH] final int len = i.read(2);
[PATCH] len = zipEncoding.decode(ch);
[PATCH] len = Math.min(len, 2);
[PATCH] len =(( int)read).length();
[PATCH] len = headerBuf.length;
[PATCH] len = skipWSOrEnd(i, read);
[PATCH] len = i.read();
[PATCH] len = len + 1 - read;
[PATCH] len = Math.min(len, read);
[PATCH] len = 2 *(len + 1);
[PATCH] len = Math.max(len, read);
[PATCH] len =(int)i.read();
[PATCH] len = len + parseNextCharacter(i);
[PATCH] len = len + 1 - ch;
[PATCH] len = len + read + 1;
[PATCH] final int len = i.read();
