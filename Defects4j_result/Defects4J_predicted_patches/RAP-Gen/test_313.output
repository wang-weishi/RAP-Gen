[PATCH] count(totalRead);
[PATCH] free(totalRead);
[PATCH] offset = offset + totalRead;
[PATCH] skip(totalRead);
[PATCH] checkRead(totalRead, numToRead);
[PATCH] checkRead(totalRead);
[PATCH] rewind(totalRead);
[PATCH] checkTotalRead(totalRead);
[PATCH] offset +=(numToRead - totalRead);
[PATCH] totalRead = skip(totalRead);
[PATCH] fill(buf, offset, totalRead);
[PATCH] limit(totalRead, numToRead);
[PATCH] validate(totalRead, numToRead);
[PATCH] scan(buf, offset, totalRead);
[PATCH] checkRead(totalRead, totalToRead);
[PATCH] totalRead = skipSpace(totalRead);
[PATCH] skip(totalRead - numToRead);
[PATCH] offset += totalRead;
[PATCH] totalRead -= skip(totalRead);
[PATCH] offset = is.mark(entryOffset);
[PATCH] conditionRead(totalRead, numToRead);
[PATCH] offset = getOffset(totalRead);
[PATCH] sumRead = skip(totalRead);
[PATCH] offset = computeOffset(totalRead);
[PATCH] checkOffset(totalRead);
[PATCH] offset = is.mark(totalRead);
[PATCH] rewind();
[PATCH] offset = skip(totalRead);
[PATCH] offset +=(int)totalRead;
[PATCH] offset = skipSpace(totalRead);
[PATCH] limit(totalRead, 0);
[PATCH] checkLen(totalRead, numToRead);
[PATCH] checkLastRead(totalRead);
[PATCH] limit(totalRead, 1);
[PATCH] repeat(totalRead, numToRead);
[PATCH] trim(totalRead);
[PATCH] validate(totalRead, totalToRead);
[PATCH] reallocate(totalRead);
[PATCH] unshare(totalRead);
[PATCH] offset +=(totalRead - numToRead);
[PATCH] offset +=(byte)totalRead;
[PATCH] checkDone(totalRead, numToRead);
[PATCH] count(totalRead, numToRead);
[PATCH] if(hasHitEOF){
[PATCH] validate(totalRead,"total read");
[PATCH] free(totalRead - totalRead);
[PATCH] numToRead -= totalRead;
[PATCH] offset +=(totalRead - totalRead);
[PATCH] len -= totalRead;
[PATCH] loopsRead += totalRead;
[PATCH] if(totalRead < 1){
[PATCH] offset +=(totalRead >> 1);
[PATCH] checkFullRead(totalRead);
[PATCH] realloc(totalRead);
[PATCH] pad(totalRead, 1);
[PATCH] remaining -= totalRead;
[PATCH] checkCapacity(totalRead);
[PATCH] checkRange(totalRead, available);
[PATCH] conditionRead(totalRead);
[PATCH] reserve(totalRead);
[PATCH] offset = offset + numToRead;
[PATCH] offset +=(totalRead << 1);
[PATCH] ensureLoaded(totalRead);
[PATCH] limit(totalRead);
[PATCH] pad(totalRead, 0);
[PATCH] entriesRead += totalRead;
[PATCH] limit(totalRead, totalToRead);
[PATCH] offset -= totalRead;
[PATCH] seek(totalRead);
[PATCH] checkCursor(totalRead);
[PATCH] checkReads(totalRead);
[PATCH] normalize(totalRead);
[PATCH] assert(totalRead < 1);
[PATCH] assert totalRead!= -1;
[PATCH] consume(totalRead);
[PATCH] validateRead(totalRead);
[PATCH] available -= totalRead;
[PATCH] discard(totalRead);
[PATCH] checkDone(totalRead);
[PATCH] size -= totalRead;
[PATCH] checkLen(totalRead);
[PATCH] waiting -= totalRead;
[PATCH] checkNextEntry();
[PATCH] pending -= totalRead;
[PATCH] assert totalRead!= available;
[PATCH] valid(totalRead);
[PATCH] validate(totalRead);
[PATCH] reset();
[PATCH] closeEntry();
[PATCH] freeTotalRead();
[PATCH] freeEntry();
[PATCH] checkRead();
[PATCH] freeRead();
[PATCH] endEntry();
[PATCH] nextEntry();
[PATCH] free();
[PATCH] read();
[PATCH]
);

