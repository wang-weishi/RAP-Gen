[PATCH] case Token.GETELEM: break;
[PATCH] case Token.GETELEM: break; case Token.GETELEM: break;
[PATCH] case Token.GETELEM: case Token.GETELEM: break;
[PATCH] default: throw new IllegalArgumentException("Node cannot be refined." + node.toStringTree());
[PATCH] case Token.GETELEM: throw new IllegalArgumentException("Node cannot be refined.");
[PATCH] case Token.GETELEM : break;
[PATCH] case Token.GETELEM: scope.inferSlotType(node); break;
[PATCH] case Token.GETELEM : case Token.GETELEM; break;
[PATCH] case Token.GETELEM: return;
[PATCH] case Token.GETELEM: node.setJSType(origType); break;
[PATCH] case Token.GETELEM: break; default: throw new IllegalArgumentException("");
[PATCH] case Token.GETELEM: node.getLastChild(); break;
[PATCH] case Token.GETELEM: case Token.GETELEM : break;
[PATCH] case Token.GETELEM: return node;
[PATCH] case Token.GETELEM: break; case Token.UNSAFE: break;
[PATCH] case Token.GETELEM: case Token.VOID: break;
[PATCH] case Token.GETELEM: break; default: throw new IllegalArgumentException(""); }
[PATCH] case Token.GETELEM: break; case Token.VOID: break;
[PATCH] case Token.GETELEM: case Token.UNSAFE: break;
[PATCH] case Token.GETELEM: break; case Token.VOID: return node;
[PATCH] case Token.GETELEM: throw new IllegalArgumentException("Node cannot be refined");
[PATCH] case Token.GETELEM: case Token.REF_SPECIAL : break;
[PATCH] case Token.GETELEM : break; case Token.GETELEM: break;
[PATCH] case Token.REF_SPECIAL: case Token.GETELEM: break;
[PATCH] case Token.GETELEM: break; case Token.REGEXP: return node;
[PATCH] case Token.GETELEM: break; case Token.GETELEM : break;
[PATCH] case Token.REF_SPECIAL : case Token.GETELEM: break;
[PATCH] case Token.GETELEM: break; case Token.THIS: break;
[PATCH] case Token.GETELEM: case Token.THIS: break;
[PATCH] case Token.GETELEM: node.removeProp(); break;
[PATCH] case Token.GETELEM: compiler.reportCodeChange(); break;
[PATCH] case Token.GETELEM: break; case Token.VOID: return null;
[PATCH] case Token.GETELEM: case Token.REF_SPECIAL: break;
[PATCH] case Token.GETELEM: throw new IllegalArgumentException("");
[PATCH] case Token.GETELEM: case Token.WHOLE_COLLECTION: break;
[PATCH] case Token.GETELEM: handleGetProp(node); break;
[PATCH] case Token.GETELEM : node.getLastChild(); break;
[PATCH] case Token.GETELEM: break; case Token.NULL: return node;
[PATCH] case Token.GETELEM: matchNode(node); break;
[PATCH] case Token.GETELEM : case Token.GETELEM: break;
[PATCH] case Token.GETELEM: throw new IllegalArgumentException("Node cannot be accessed");
[PATCH] case Token.GETELEM: type = node.getLastChild(); break;
[PATCH] case Token.GETELEM: doFindProperty(node, qualifiedName); break;
[PATCH] case Token.INVOKESTATIC: break;
[PATCH] case Token.GETELEM: visitGetProp(node); break;
[PATCH] case Token.GETELEM: break; case Token.REFERENCE: return node;
[PATCH] case Token.GETELEM: node.remove(); break;
[PATCH] case Token.GETELEM: break; case Token.NULL: break;
[PATCH] case Token.GETELEM: doGetProp(node); break;
[PATCH] case Token.GETELEM: inferSlotType(node); break;
[PATCH] case Token.GETELEM: doFindSlot(node); break;
[PATCH] case Token.GETELEM: doFindProperty(node); break;
[PATCH] case Token.REF_SPECIAL: break;
[PATCH] default: throw new IllegalArgumentException("");
[PATCH] case Token.SETPROP: case Token.GETELEM: break;
[PATCH] case Token.GETELEM: case Token.CATCH: break;
[PATCH] case Token.GETELEM: return true;
[PATCH] case Token.REF_SPECIAL : break;
[PATCH] case Token.GETELEM: continue;
[PATCH] case Token.REF_SPECIAL: return node;
[PATCH] case Token.SETPROP: break;
[PATCH] case Token.GETELEM: doGetProp(); break;
[PATCH] c case Token.GETELEM: break;
[PATCH] case Token.GETELEM : throw new IllegalArgumentException("");
[PATCH] case Token.VOID: return node.getJSType();
[PATCH] case Token.GETELEM: break;
[PATCH] case Token.NAME: return node.getString();
[PATCH] case Token.REGEXP: return node.toStringTree();
[PATCH] case Token.REF_SPECIAL: return;
[PATCH] case Token.WHOLE_COLLECTION: break;
[PATCH] case Token.GETELEM: return false;
[PATCH] case Token.SETPROP: return node;
[PATCH] case Token.GETELEM: fallthrough;
[PATCH] case Token.GETELEM: return, node;
[PATCH] case Token.GETELEM: ignore(); break;
[PATCH] case Token.GETELEM : return;
[PATCH] ccase Token.GETELEM: break;
[PATCH] case Token.VOID: break;
[PATCH] case Token.UNSAFE: break;
[PATCH] case Token.THIS: break;
[PATCH] case getToken.GETELEM: break;
[PATCH] case Token.GETPROP: break;
[PATCH] case Token.SETPROP : break;
[PATCH] case Token.GOTO: break;
[PATCH] case Token.GETELEM:
[PATCH] case Token.GETTER: break;
[PATCH] case Token.ASSIGN: break;
[PATCH] case Token.CALL: break;
[PATCH] default: throw new IllegalArgumentException(""); }
[PATCH] case Token.NULL: break;
[PATCH] case Token.NEW: break;
[PATCH] default: break;
[PATCH] endOfProperty();
[PATCH] endProperty();
[PATCH] break;
[PATCH]
[PATCH] next();
[PATCH] pass;
[PATCH] ;
);
