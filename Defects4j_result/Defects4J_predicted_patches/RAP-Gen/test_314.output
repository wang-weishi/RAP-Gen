[PATCH] getAndMoveToFrontDecode();
[PATCH] this.in.seek(offs);
[PATCH] ensureOpen();
[PATCH] this.in.mark(offs);
[PATCH] final int offs = offset(offs);
[PATCH] final int offs = getOffset(offs);
[PATCH] final int offs = getOffset();
[PATCH] recvDecodingTables();
[PATCH] seek(offs);
[PATCH] pos = bsR(1);
[PATCH] write(dest, 0, offs);
[PATCH] bsW(offs, len);
[PATCH] this.in.skip(offs);
[PATCH] pos = bsR(offs);
[PATCH] final int offs = getOffset(dest);
[PATCH] read(dest, 0, len);
[PATCH] mark(1);
[PATCH] checkLimits(offs, len);
[PATCH] bsR(offs, len);
[PATCH] final int offs = offset();
[PATCH] readAndMoveToFrontDecode();
[PATCH] mark(len);
[PATCH] offset = checkOffset(offs);
[PATCH] add(dest, offs, len);
[PATCH] final int offs = offset(dest);
[PATCH] init();
[PATCH] read(dest, offs, len);
[PATCH] int offs = findOffset(offs);
[PATCH] chunks(dest, offs, len);
[PATCH] this.in.reset();
[PATCH] pos = findOffset(offs);
[PATCH] align(offs, len);
[PATCH] super.seek(offs);
[PATCH] write(dest, 0, len);
[PATCH] add(dest, 0, offs);
[PATCH] pos = this.in.mark();
[PATCH] offset = calcOffset(offs);
[PATCH] int offs = getOffset(offs);
[PATCH] moveToFrontDecode();
[PATCH] in.seek(offs);
[PATCH] this.in.seek(offset);
[PATCH] ensureCapacity(len);
[PATCH] verifyLimits(offs, dest);
[PATCH] final int len = read1();
[PATCH] pos = bsR(2);
[PATCH] buff.seek(offs);
[PATCH] checkOffset(offs, len);
[PATCH] int offs = offset(offs);
[PATCH] bsR(1, 1);
[PATCH] offset = bsR(offs);
[PATCH] checkMoveToFrontDecode();
[PATCH] checkLimits(offs, dest);
[PATCH] mark(0);
[PATCH] bsR(1);
[PATCH] pos = bsR(4);
[PATCH] pos = calcOffset(offs);
[PATCH] pos = calcPos(offs);
[PATCH] rewind();
[PATCH] offset = calculateOffset(offs);
[PATCH] mark(offs, len);
[PATCH] pos = bsR(8);
[PATCH] reset();
[PATCH] verifyLimits(offs, len);
[PATCH] endBlock();
[PATCH] checkLimits();
[PATCH] pos = bsGetInt();
[PATCH] pos = getOffset(offs);
[PATCH] checkOffset(offs);
[PATCH] setPos(offs);
[PATCH] throw new IOException("");
[PATCH] clear();
[PATCH] expect(1);
[PATCH] count(1);
[PATCH] bsR(2);
[PATCH] int offs = getOffset();
[PATCH] recv();
[PATCH] pos = getOffset();
[PATCH] setup();
[PATCH] unshare(dest);
[PATCH] bsR(4);
[PATCH] crc.reset();
[PATCH] close();
[PATCH] super();
[PATCH] init(dest);
[PATCH] checkOpen();
[PATCH] assumesOpen();
[PATCH] position(offs);
[PATCH] size(1);
[PATCH] size(len);
[PATCH] mark(offs);
[PATCH] expect(0);
[PATCH] read();
[PATCH] verifyLimits();
[PATCH] start();
[PATCH] --len;
[PATCH] bsSet();
[PATCH] bsGet();
[PATCH] startBlock();
[PATCH] quickPeek();
[PATCH] readImpl();
