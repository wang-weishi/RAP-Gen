[PATCH] Preconditions.checkNotNull(parent);
[PATCH] boolean hasClassOrEnumDescendant = parent.canCollapseUnannotatedChildNames();
[PATCH] Preconditions.checkNotNull(type);
[PATCH] boolean hasClassOrEnumDescendant = parent.isClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = type == Type.OBJECTLIT;
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum(parent.getType());
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum(type);
[PATCH] Preconditions.checkNotNull(externsRoot);
[PATCH] boolean hasClassOrEnumDescendant = NodeUtil.isClassOrEnum(parent);
[PATCH] Preconditions.checkNotNull(externsScope);
[PATCH] boolean isClassOrEnum = parent.canCollapseUnannotatedChildNames();
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum(node.getFirstChild());
[PATCH] Preconditions.checkArgument(parent!= null);
[PATCH] Preconditions.checkState(parent!= null);
[PATCH] boolean hasClassOrEnum = parent.canCollapseUnannotatedChildNames();
[PATCH] Preconditions.checkNotNull(aliasingGets);
[PATCH] Preconditions.checkNotNull(declaration);
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum(declaration.getType());
[PATCH] boolean hasClassOrEnumDescendant = Type.isClassOrEnum(type);
[PATCH] boolean hasClassOrEnumDescendant = this.isClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = type.equals(Type.OBJECTLIT);
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = type.equals(OBJECTLIT);
[PATCH] boolean hasClassOrEnumDescendant = NodeUtil.isClassOrEnumType(parent);
[PATCH] Preconditions.checkState(parent!= null,"Cannot find class name");
[PATCH] Preconditions.checkState(type == Type.OBJECTLIT);
[PATCH] NodeTraversal.traverse(compiler, nameObj, this);
[PATCH] boolean hasClassOrEnumDescendant = NodeUtil.isClassOrEnum(node);
[PATCH] boolean hasClassOrEnumDescendant = compiler.getCodingConvention().isClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum(parent.getParent());
[PATCH] boolean isClassOrEnum = parent.isClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = parent.hasClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = NodeUtil.isClassOrEnum(declaration);
[PATCH] boolean hasClassOrEnumDescendant = ClassUtils.isClassOrEnum(parent);
[PATCH] Preconditions.checkNotNull(name);
[PATCH] boolean hasClassOrEnumDescendant = parent.getType() == Token.CLASS;
[PATCH] boolean hasClassOrEnumDescendant = parent.getClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = NodeUtil.isClassOrEnum(type);
[PATCH] boolean isClassOrEnum =(parent == null || parent.isClassOrEnum());
[PATCH] boolean hasClassOrEnumDescendant = NodeUtil.isLiteralValue(parent);
[PATCH] Preconditions.checkState(parent!= null,"Cannot find root object");
[PATCH] Preconditions.checkState(compiler.isNormalized());
[PATCH] Preconditions.checkState(isClassOrEnumDescendant);
[PATCH] boolean hasClassOrEnumDescendant = type.equals(TYPE.OBJECTLIT);
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = ClassReader.isClassOrEnum(declaration);
[PATCH] NodeTraversal.traverse(compiler, parent, this);
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum(node.getParent());
[PATCH] boolean hasClassOrEnumDescendant = NodeUtil.isClassOrEnumType(type);
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum(node.getType());
[PATCH] Preconditions.checkNotNull(valueNode);
[PATCH] Preconditions.checkState(aliasingGets == 0);
[PATCH] boolean hasClassOrEnumDescendant = Type.isClassOrEnum(parent);
[PATCH] Preconditions.checkArgument(parent!= null,"Cannot find class name");
[PATCH] boolean hasClassOrEnumDescendant = type.equals(Type.CLASS);
[PATCH] boolean isClassOrEnum = NodeUtil.isClassOrEnum(parent);
[PATCH] boolean hasClassOrEnumDescendant = nameMap.containsKey(parent);
[PATCH] boolean hasClassOrEnumDescendant = _isClassOrEnum(type);
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum(type);
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnumType(parent.getType());
[PATCH] Preconditions.checkState(parent!= null,"Cannot find property value");
[PATCH] Preconditions.checkState(parent!= null,"Cannot find parent object");
[PATCH] boolean hasClassOrEnumDescendant = nameIsClassOrEnum(name);
[PATCH] Preconditions.checkNotNull(valueType);
[PATCH] boolean hasClassOrEnum = parent.isClassOrEnum();
[PATCH] Preconditions.checkArgument(parent!= null,"Cannot find root object");
[PATCH] boolean hasClassOrEnumDescendant = ClassReader.isClassOrEnum(node);
[PATCH] int aliasingGets = parent.isClassOrEnum();
[PATCH] boolean isClassOrEnum = isClassOrEnumDescendant();
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnumType();
[PATCH] Preconditions.checkState(parent!= null,"Cannot find class value");
[PATCH] boolean hasClassOrEnumDescendant = type.equals(TYPE.CLASS);
[PATCH] Preconditions.checkNotNull(valueNodeType);
[PATCH] Preconditions.checkState(childSets == 0);
[PATCH] Preconditions.checkState(parent!= null,"Cannot find property accessor");
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnumType(type);
[PATCH] parent = parent.getParent();
[PATCH] int aliasingGets = parent.getClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum(node);
[PATCH] Preconditions.checkArgument(parent!= null,"Cannot find parent object");
[PATCH] boolean hasClassOrEnumDescendant = containsClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = isInExterns();
[PATCH] Preconditions.checkState(parent!= null,"Cannot find property name");
[PATCH] Preconditions.checkNotNull(topVarName);
[PATCH] Node parent = parent.getParent();
[PATCH] boolean hasClassOrEnumDescendant = isUnannotatedClassOrEnum();
[PATCH] boolean hasClassOrEnumDescendant = isClassOrEnum(parent);
[PATCH] Preconditions.checkNotNull(baseName);
[PATCH] boolean hasClassOrEnum = isClassOrEnumDescendant();
[PATCH] boolean hasClassOrEnumDescendant = _isClassOrEnum();
[PATCH] Preconditions.checkNotNull(sourceName);
[PATCH] boolean hasClassOrEnumDescendant = hasClassOrEnum();
[PATCH] Preconditions.checkNotNull(childName);
[PATCH] Preconditions.checkNotNull(key);
[PATCH] boolean isClassOrEnum = hasClassOrEnumDescendant();
[PATCH] boolean hasClassOrEnumDescendant = getClassOrEnum();
[PATCH] Preconditions.checkNotNull(value);
[PATCH] checkInvariant();
[PATCH] checkClassOrEnum();
[PATCH] checkSimpleName();
