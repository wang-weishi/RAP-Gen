[PATCH] validateState(totalRead);
[PATCH] roundFloor(totalRead);
[PATCH] checkLenient(totalRead);
[PATCH] skip(totalRead);
[PATCH] ensureCapacity(totalRead);
[PATCH] backup(totalRead);
[PATCH] ensureLoaded(totalRead);
[PATCH] totalRead = skip(totalRead);
[PATCH] invalidateRangeInfo(totalRead);
[PATCH] seek(totalRead);
[PATCH] freeEntryBytes(totalRead);
[PATCH] normalize(totalRead);
[PATCH] checkRange(totalRead);
[PATCH] skipAllRecordBytes(totalRead);
[PATCH] freeEntryBuffer(totalRead);
[PATCH] min(totalRead, numToRead);
[PATCH] skipEOFs(totalRead);
[PATCH] validate(totalRead);
[PATCH] freeEntry();
[PATCH] checksum(totalRead);
[PATCH] limit(totalRead);
[PATCH] skippingRead(totalRead);
[PATCH] validateLength(totalRead);
[PATCH] skipAllBytes(totalRead);
[PATCH] skipToSkip(totalRead);
[PATCH] validateIndex(totalRead);
[PATCH] entrySize += skip(totalRead);
[PATCH] validateSize(totalRead);
[PATCH] normalizeEntryCount(totalRead);
[PATCH] translateRead(totalRead);
[PATCH] failOnEOF(totalRead);
[PATCH] expiration(totalRead);
[PATCH] skippingRead();
[PATCH] offset += skip(totalRead);
[PATCH] trimToSkip(totalRead);
[PATCH] trimToRead(totalRead);
[PATCH] normalizeEntrySize(totalRead);
[PATCH] unconditional(totalRead);
[PATCH] truncate(totalRead);
[PATCH] trimToRecord(totalRead);
[PATCH] convertToRecord(totalRead);
[PATCH] validateRange(totalRead);
[PATCH] offset += min(totalRead);
[PATCH] skipAllRecordData(totalRead);
[PATCH] skipBytes(totalRead);
[PATCH] align(totalRead);
[PATCH] assert totalRead < numToRead;
[PATCH] numToSkip -= totalRead;
[PATCH] saveEntry(currEntry);
[PATCH] validateRead(totalRead);
[PATCH] trim(totalRead);
[PATCH] countRecord(totalRead);
[PATCH] skipFully(totalRead);
[PATCH] skipping(totalRead);
[PATCH] invalidateRangeInfo();
[PATCH] validateState();
[PATCH] validity(totalRead);
[PATCH] lookAhead(totalRead);
[PATCH] verifyRead(totalRead);
[PATCH] skipRecord(totalRead);
[PATCH] validateNumber(totalRead);
[PATCH] skippingRead += totalRead;
[PATCH] handleRead(totalRead);
[PATCH] skips(totalRead);
[PATCH] freeEntry(currEntry);
[PATCH] checkLenient();
[PATCH] entrySize += totalRead;
[PATCH] checksum += totalRead;
[PATCH] expand(totalRead);
[PATCH] etag(totalRead);
[PATCH] offset += totalRead;
[PATCH] skipAllRead();
[PATCH] ptime(totalRead);
[PATCH] rotate(totalRead);
[PATCH] inc(totalRead);
[PATCH] discard(totalRead);
[PATCH] seek(entryOffset);
[PATCH] checkLenientRead();
[PATCH] invalidateRangeInfo(numToRead);
[PATCH] skipAllRecordData();
[PATCH] reset();
[PATCH] min(totalRead);
[PATCH] freeRecord();
[PATCH] freeEntryData();
[PATCH] checkState(totalRead < 0);
[PATCH] closeEntry();
[PATCH] skipAllReads();
[PATCH] ensureOpen();
[PATCH] nextRecord();
[PATCH] assert totalRead < numToRead);
[PATCH] checkState(totalRead);
[PATCH] validateRead();
[PATCH] freeRead();
[PATCH] normalize();
[PATCH] normalizeRead();
[PATCH] nextEntry();
[PATCH] convertRead();
[PATCH] skipWrite();
[PATCH] calcRead();
[PATCH] skipRead();
