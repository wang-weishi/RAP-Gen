[PATCH] Preconditions.checkState(first!= null);
[PATCH] Preconditions.checkNotNull(first);
[PATCH] Preconditions.checkArgument(NodeUtil.isGet(first));
[PATCH] Preconditions.checkState(NodeUtil.isGet(first));
[PATCH] Preconditions.checkArgument(first!= null);
[PATCH] n.replaceChild(first, new Node(Token.NEW));
[PATCH] n.removeChild(first);
[PATCH] annotateCallAnnotations(n, first);
[PATCH] first = first.getNext();
[PATCH] Preconditions.checkState(first!= n.getFirstChild());
[PATCH] NodeTraversal.traverse(compiler, first, this);
[PATCH] NodeUtil.removeChild(n.getParent(), n);
[PATCH] NodeUtil.removeChild(first.getNext(), first);
[PATCH] n.getFirstChild().setType(Token.CALL);
[PATCH] NodeTraversal.traverse(compiler, n, this);
[PATCH] n.replaceChild(first, new Node(Token.CALL));
[PATCH] if(!first.hasChildren()){ return; }
[PATCH] NodeUtil.annotateCallAnnotations(n, first);
[PATCH] annotateCalls(first);
[PATCH] n.replaceChild(first, new Node(Token.EMPTY));
[PATCH] annotateCalls(first, n.getLastChild());
[PATCH] annotateCalls(n, first);
[PATCH] NodeUtil.removeChild(first.getParent(), first);
[PATCH] n.addChildToBack(first);
[PATCH] Preconditions.checkState(!first.hasChildren());
[PATCH] Preconditions.checkArgument(NodeUtil.isName(first));
[PATCH] NodeTraversal.traverse(compiler, n, new PrepareAnnotations());
[PATCH] callNodeToParentMap.put(n, first);
[PATCH] addStubsForUndeclaredProperties(n, first);
[PATCH] NodeTraversal.traverse(compiler, first, new PrepareAnnotations());
[PATCH] n.replaceChild(first, new Node(Token.RETURN));
[PATCH] first = Node.newString(Token.NAME, first);
[PATCH] checkOnly = checkOnly || NodeUtil.isGet(first);
[PATCH] first = checkOnly? first : n.getFirstChild();
[PATCH] NodeUtil.removeChild(first.getNext(), n);
[PATCH] Preconditions.checkState(NodeUtil.isName(first));
[PATCH] first.setType(Token.CALL);
[PATCH] n.getFirstChild().setIsNoSideEffectsCall();
[PATCH] n.replaceChild(first, first.cloneTree());
[PATCH] if(!first.isNext()){ return; }
[PATCH] annotateCallAnnotations(first, n.getLastChild());
[PATCH] NodeTraversal.traverse(compiler, n, annotateCalls);
[PATCH] annotateCallAnnotations(first);
[PATCH] annotateCalls(first, n);
[PATCH] annotateCallSegments(n, first);
[PATCH] first = first.getFirstChild();
[PATCH] NodeUtil.redeclareVarsInsideBranch(n);
[PATCH] first = Node.newString(Token.NAME,"call");
[PATCH] processFunctionCall(n, first);
[PATCH] Preconditions.checkState(!first.isGetProp());
[PATCH] Preconditions.checkArgument(!first.isGetProp());
[PATCH] annotateCallCandidates(n, first);
[PATCH] NodeUtil.validateState(first!= null);
[PATCH] addPossibleSignature(first, n.getLastChild());
[PATCH] addCallAnnotations(n, first);
[PATCH] annotateCalls(first, n.getFirstChild());
[PATCH] Preconditions.checkArgument(!first.hasChildren());
[PATCH] n.setFirstChild(first);
[PATCH] checkOnly && NodeUtil.isGet(first);
[PATCH] NodeUtil.validateCall(n, first);
[PATCH] NodeUtil.checkNotNull(first);
[PATCH] n.removeFirstChild();
[PATCH] checkOnly = NodeUtil.isGet(first);
[PATCH] first = first.getNext().getFirstChild();
[PATCH] first = first.getNext().getNext();
[PATCH] n.addChildToFront(first);
[PATCH] int len = first.getChildCount();
[PATCH] new Node(Token.CALL, first);
[PATCH] collectCallAnnotations(n, first);
[PATCH] NodeUtil.checkState(first!= null);
[PATCH] processCall(n, first);
[PATCH] annotateCallAnnotations(first, n);
[PATCH] annotateCallProperties(n, first);
[PATCH] collectCallCandidates(n, first);
[PATCH] annotateCall(n, first);
[PATCH] super.annotateCalls(n);
[PATCH] NodeUtil.skipChildren(first);
[PATCH] ast.addChildToBack(first);
[PATCH] final Node last = first.getNext();
[PATCH] declareVarsInsideBranch(n, first);
[PATCH] annotateCallTail(n, first);
[PATCH] n.annotateChild(first);
[PATCH] first = Node.newExpr(first);
[PATCH] first.setIsGet(true);
[PATCH] annotateMethods(n, first);
[PATCH] annotateCalls(first.getNext());
[PATCH] mergeCallAnnotations(n, first);
[PATCH] NodeUtil.validateCall(first);
[PATCH] NodeUtil.normalizeCall(n);
[PATCH] annotateAnnotations(n, first);
[PATCH] annotateArguments(n, first);
[PATCH] annotateCallbacks(n, first);
[PATCH] addMethodCallAnnotations(n, first);
[PATCH] validateState(first!= null);
[PATCH] validateCall(n, first);
[PATCH] Annotations.checkNotNull(first);
[PATCH] Validate.notNull(first);
[PATCH] annotations.add(first);
[PATCH] compiler.reportCodeChange();
[PATCH] createNode(first);
