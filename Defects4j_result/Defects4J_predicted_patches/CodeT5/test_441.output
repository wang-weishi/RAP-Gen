[PATCH] case Token.OBJECTLIT: return false;
[PATCH] case Token.OBJECTLIT: return newHasLocalResult(value);
[PATCH] case Token.OBJECTLIT: return locals.apply(value);
[PATCH] case Token.OBJECTLIT: return objectHasLocalResult(value);
[PATCH] case Token.OBJECT_METHOD: return newHasLocalResult(value);
[PATCH] case Token.OBJECTFIELD: return newHasLocalResult(value);
[PATCH] case Token.OBJECTREF: return newHasLocalResult(value);
[PATCH] case Token.OBJECTLIT : return newHasLocalResult(value);
[PATCH] case Token.OBJECTMETHOD: return newHasLocalResult(value);
[PATCH] case Token.OBJECTLIT: return objectValueEqualsSilent(value);
[PATCH] default: return value.getType() == Token.STRING;
[PATCH] case Token.STRING: return newHasLocalResult(value);
[PATCH] case Token.OBJECTLIT: return objectLitValueEquals(value);
[PATCH] case Token.OBJECTLIT: return evalFunction(value, locals);
[PATCH] case Token.OBJECTLIT: return objectEqualsSilent(value);
[PATCH] case Token.OBJECTLIT, locals.apply(value);
[PATCH] case Token.OBJECTLIT: return objectLitEqualsSilent(value);
[PATCH] case Token.OBJECTLIT: return hasLocalResult(value);
[PATCH] case Token.OBJECTREF: return locals.apply(value);
[PATCH] case Token.OBJECTLIT: return objectValueEquals(value);
[PATCH] case Token.OBJECTFIELD: return locals.apply(value);
[PATCH] case Token.OBJECT_METHOD: return locals.apply(value);
[PATCH] case Token.OBJECTLIT: return objectLiteralValueEquals(value);
[PATCH] case Token.OBJECTLIT: return evalRegularExpression(value, locals);
[PATCH] case Token.OBJECTVAR: return newHasLocalResult(value);
[PATCH] case Token.OBJECTSUB: return newHasLocalResult(value);
[PATCH] case Token.OBJECTLIT: return objectIsSubtype(value);
[PATCH] case Token.OBJECTSTR: return newHasLocalResult(value);
[PATCH] case Token.OBJECTLIT: return super.evaluate(value, locals);
[PATCH] case Token.OBJECTLIT: returnfalse;
[PATCH] case Token.OBJECTLIT: return(( Node)value).isQualifiedName();
[PATCH] case Token.LOCAL: return locals.apply(value);
[PATCH] case Token.STRING: return locals.apply(value.getString());
[PATCH] case Token.OBJECTLIT: return objectLits.contains(value);
[PATCH] case Token.OBJECTLIT: return objectLitEquals(value, locals);
[PATCH] case Token.OBJECTLIT: return!isObjectLitValue(value);
[PATCH] case Token.OBJECTLIT: return objectIsObjectLit(value);
[PATCH] case Token.OBJECTLIT: return objectValueEquals(value, locals);
[PATCH] default: return value.getType() == Token.NUMBER;
[PATCH] case Token.OBJECTLIT: return!isObjectLitLocal(value);
[PATCH] case Token.OBJECTLIT: return objectValueContainsSubtype(value);
[PATCH] case Token.OBJECTLIT: return!isObjectLitKey(value);
[PATCH] case Token.OBJECTLIT: return objectLitHasLocalResult(value);
[PATCH] case Token.LOCAL: return newHasLocalResult(value);
[PATCH] case Token.BITNOT: return false;
[PATCH] case Token.OBJECTLIT : return locals.apply(value);
[PATCH] default: return value.getType() == Token.NAME;
[PATCH] case Token.OBJECTNAME: return newHasLocalResult(value);
[PATCH] case Token.OBJECTLIT: return evalFunctionValue(value, locals);
[PATCH] case Token.OBJECTLIT: return objectExprEqualsSilent(value);
[PATCH] case Token.OBJECTMETHOD: return locals.apply(value);
[PATCH] case Token.OBJECTFIELD: return objectFieldEquals(value, locals);
[PATCH] case Token.OBJECTLIT: return!isImmutableValue(value);
[PATCH] case Token.THIS: return false;
[PATCH] case Token.OBJECTLIT : return false;
[PATCH] case Token.OBJECTLIT: return!(isLiteralValue(value));
[PATCH] case Token.OBJECTNAME: return newIsLocalResult(value);
[PATCH] case Token.OBJECTLIT: return equalStrings(value, locals);
[PATCH] case Token.OBJECTMETHOD: return objectMethodEqualsSilent(value);
[PATCH] default: return!isLiteralValue(value);
[PATCH] case Token.OBJECT_METHOD: return false;
[PATCH] case Token.OBJECTLIT: return equalStrings(value.getString());
[PATCH] case Token.OBJECT_METHOD: return objectMethodEquals(value);
[PATCH] case Token.STRING: return false;
[PATCH] case Token.OBJECTLIT: return deepestSubtype(value);
[PATCH] case Token.OBJECTLIT: return!isLiteralValue(value);
[PATCH] case Token.OBJECTLIT: return true;
[PATCH] case Token.NAME: return value.getString().equals(name);
[PATCH] case Token.OBJECTLIT: return instanceofValue(value);
[PATCH] case Token.COMMA: return false;
[PATCH] case Token.OBJECTLIT, return false;
[PATCH] case Token.OBJECTLIT: return hasLocalValue(value);
[PATCH] case Token.SYNTAX: return false;
[PATCH] default: throw new MatchNotFunction(value, locals);
[PATCH] case Token.OBJECTNAME: return nameEquals(value.getString());
[PATCH] default: return evalFunction(value, locals);
[PATCH] case Token.OBJECTNAME: return false;
[PATCH] default: return locals.apply(value);
[PATCH] case Token.OBJECTREF: return false;
[PATCH] case Token.OBJECT_METHODS: return false;
[PATCH] case Token.OBJECTS: return false;
[PATCH] case Token.OBJECTMETHOD: return false;
[PATCH] case Token.OBJECTREF: return true;
[PATCH] case Token.FALSE: return false;
[PATCH] case Token.BOOLEAN: return false;
[PATCH] case Token.OBJECTSUB: return false;
[PATCH] default: throw new IllegalStateException("");
[PATCH] case Token.OBJECTNOT: return false;
[PATCH] case Token.NOT: return false;
[PATCH] case Token.OBJECTRETURN: return false;
[PATCH] case Token.INSTANCEOF: return false;
[PATCH] case Token.OBJECTCALL: return false;
[PATCH] case Token.GETPROP: return false;
[PATCH] default: return isImmutableValue(value);
[PATCH] case Token.OBJECTFIELD: return false;
[PATCH] case Token.COLON: return false;
[PATCH] default: return isLiteralValue(value);
[PATCH] case Token.OBJECTSIZE: return false;
[PATCH] default: return false;
[PATCH] default: throw new IllegalArgumentException("");
